// Make all fields optional for testing
// TODO: Remove when API is stable

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  CREATOR
  USER
}

enum Status {
  PENDING
  ACCEPTED
  REJECTED
}

enum academicRole {
  ALUMNO
  EXALUMNO
  PROFESOR
  COORDINADOR
  DEPARTMENTO
}

model User {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  fullName String?

  email         String?  @unique
  emailVerified Boolean? @default(false)
  username      String?  @unique
  passwordHash  String?

  role Role? @default(USER)

  academicRole academicRole?

  position       String?
  promotion      String?
  academicCourse String?

  // Solo para coordinadores tienen un departamento
  //headOfDepartmentId String?     @unique @db.ObjectId
  //headOfDepartment   Department? @relation(fields: [headOfDepartmentId], references: [id])

  degreeId String? @db.ObjectId
  degree   Degree? @relation(fields: [degreeId], references: [id])

  requests Request[]

  involvedAsStudentIDs String[]  @db.ObjectId
  involvedAsStudent    Project[] @relation(fields: [involvedAsStudentIDs], references: [id], name: "involvedAsStudent")

  involvedAsProfessorIDs String[]  @db.ObjectId
  involvedAsProfessor    Project[] @relation(fields: [involvedAsProfessorIDs], references: [id], name: "involvedAsProfessor")

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  @@map("users")
}

model Project {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  status  Status?   @default(PENDING)
  Request Request[]

  title       String
  type        String?
  description String?

  summary        String?
  report         String?
  differentiator String?
  keywords       String[]
  awards         String[]

  subject         String?
  personalProject Boolean?

  academicCourse String?
  course         String?
  letter         String?

  externalLinks   String[]
  uploadedContent String[]

  areaId String? @db.ObjectId
  area   Area?   @relation(fields: [areaId], references: [id])

  degreeId String? @db.ObjectId
  degree   Degree? @relation(fields: [degreeId], references: [id])

  impliedStudentsIDs String[] @db.ObjectId
  impliedStudents    User[]   @relation(fields: [impliedStudentsIDs], references: [id], name: "involvedAsStudent")

  impliedProfessorsIDs String[] @db.ObjectId
  impliedProfessors    User[]   @relation(fields: [impliedProfessorsIDs], references: [id], name: "involvedAsProfessor")

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  @@map("projects")
}

model Degree {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  name String @unique

  areasId String[] @db.ObjectId
  areas   Area[]   @relation(fields: [areasId], references: [id])

  projects Project[]
  users    User[]

  @@map("degrees")
}

model Area {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  name String @unique

  degreesId String[]  @db.ObjectId
  degrees   Degree[]  @relation(fields: [degreesId], references: [id])
  Project   Project[]

  @@map("areas")
}

model Request {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  status Status? @default(PENDING)

  projectId String  @db.ObjectId
  project   Project @relation(fields: [projectId], references: [id])

  projectTitle String?
  description  String?

  academicCourse String?

  requester   User   @relation(fields: [requesterId], references: [id])
  requesterId String @db.ObjectId

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  @@map("requests")
}
